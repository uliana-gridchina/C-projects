size_t strlen( const char *s )
Возвращает количество символов с строке без учета '\0'
size_t - беззнаковый целый тип для предоставления размера любого объекта в памяти

char *strcpy( char *destination, const char *source)
Копирует строку source в строку destination, включая '\0'
Возвращает указатель на строку destination
char s1[] = "hihihi"
char s2[] = "hahaha"
strcpy(*s1, *s2)
prinf("%s %s", s1, s2) : hahaha hahaha

char *strncpy( char *destination, const char *source, size_t n )
Копирует не более n символов строки source в строку destination, завершая строку '\0'
Возвращает указатель на строку destination

char *strcat( char *destinaton, const char *source )
Присоединяет строку source к строке destination, включая '\0'
Возвращает указатель на строку destination

char *strncat( char *dest, const char *src, size_t n )
Присоединяет не более n символов строки source к строке destination, завершая строку '\0'
Возвращает указатель на строку destination

int strcmp( const char *s1, const char *s2 )
Сравнивает две строки s1 и s2
Возвращает 0, если строки равны
          >0, если первый несовпадающий элемент строки s1 имеет код больший, чем элемент с этим же индексом в строке s2
          <0, если первый несовпадающий элемент строки s1 имеет код меньший, чем элемент с этим же индексом в строке s2

int strncmp( const char *s1, const char *s2, size_t n )
Сравнивает не более n символов строк s1 и s2
-\\-

char *strchr( const char *s, int c )
Ищет в строке s первое вхождение символа c, начиная с начала строки
В случае успеха возвращает указатель на найденный символ, иначе возвращает NULL
int c - код исходного символа

char *strrchr( const char *s, int c )
Ищет в строке s первое вхождение символа c, начиная с конца строки
В случае успеха возвращает указатель на найденный символ, иначе возвращает NULL

char *strstr( const char *mainstr, const char *substr )
Ищет первое вхождение строки substr в строке mainstr
В случае успеха возвращает указатель на первое вхождение строки substr в строке mainstr, иначе NULL
*Если строка substr имеет нулевую длину, то вернется указатель на начало строки mainstr

size_t strspn ( const char *mainstr, const char *substr )
Определяет наибольшую длину начального участка строки mainstr, в который входят только символы из строки substr
Вовзращает длину начального участка строки mainstr
*Если первый элемент стрроки mainstr не входит в строку substr, возвращается 0
mainstr – строка, в которой ведется поиск
substr – строка с набором символов, которые должны входить в участок строки mainstr

size_t strcspn ( const char *mainstr, const char *substr )
Определяет наибольшую длину начального участка строки mainstr, в который не входит ни один из символов строки substr
Возвращает длину начального участка строки mainstr
mainstr – указатель на строку, в которой будет осуществляться определение длины участка, не содержащего символов указанных в строке sym.
substr – строка с набором символов, которые не должны входить в участок строки mainstr

char *strpbrk ( const char *mainstr, const char *substr )
Ищет первое вхождение символа из строки substr в строке mainstr
В случае успеха возвращает указатель на первый найденный элемент в строке mainstr, иначе NULL
mainstr – указатель на строку, в которой ведется поиск
substr – указатель на строку с набором искомых символов

char *strcasestr ( const char *mainstr, const char *substr )
Ищет первое вхождение строки substr в строке mainstr
В случае успеха возвращает указатель на первое вхождение строки substr в строке mainstr, иначе NULL
Если строка substr имеет нулевую длину, то вернется указатель на начало строки mainstr
*При поиске не учитывается регист символов

char *strtok( char *str, const char *sep )
Выделяет очередную часть строки str, отделенную одним из символов и строки sep
Возвращает указатель на первый символ выделенной части строки str, если строку str невозможно разделить - NULL
Алгоритм:
При первом вызове функции strtok указывается начало разделяемой строки str и начало строки, содержащей разделители sep. В начале функция strtok поочередно просматривает символы строки str и ищет символ, не содержащейся в строке разделителей sep. Если в строке str символ конца строки встречен раньше, чем был найден символ не входящий в строку sep, то разделить строку str на части нельзя и возвращается нулевой указатель NULL. Если такой символ найден, он считается началом первой части строки str
Далее функция strtok ищет разделитель, то есть символ, входящий в строку sep. Если такой символ не найден, то считается, что строка str состоит из одной части и последующее разделения строки str будут возвращать NULL. Если такой символ найден, то он заменяется '\0'. Далее функция strtok запоминает текущую позицию (указатель на символ, с которого будет начинаться поиск следующей части строки) и возвращает указатель на начало первой выделенной части строки
Если функция strtok вернула не нулевой указатель, можно продолжить разбиение строки str на части. Для продолжения разбиения строки, повторно вызывается функция strtok, но вместо указателя на разбиваемую строку в качестве первого аугмента указывается NULL. В этом случае функция strtok продолжит разбиение с запомненного адреса

char *strdup( const char *str )
Дублирует строку str
Возвращает указатель на дублированную строку. Если не удалось выделить память или скопировать строку str - NULL
*Память под дубликат выделяется с помощью функции malloc. По окончании программы память должна быть очищена с помощью функции free

char *strndup( const char *str, size_t n )
Дублирует строку str, с ограничение по количеству байт. Если строка меньше n байт, то дублирует вся строка, если больше, то только n байт строки str
Возвращает указатель на дублированную строку. Если не удалось выделить память или скопировать строку str - NULL
*Память под дубликат выделяется с помощью функции malloc. По окончании программы память должна быть очищена с помощью функции free



char *strchrnul( const char *s, int c )
Ищет в строке s первое вхождение символа c, начиная с начала строки
В случае успеха возвращает указатель на найденный символ, иначе указатель на '\0' в конце строки

char *strerror( int errcode )
Формирует описание ошибки по указанному коду в аргументе
Возвращает указатель на строку, содержащую сформированное описание ошибки



void *memcpy( void *destination, const void *source, size_t n )
destination – массив в который будут скопированы данные
source – массив источник копируемых данных
n – количество байт для копировани
*Если массивы перекрываются, результат копирования будет не определен

void *memccpy( void *destination, const void *source, int c, size_t n )
destination – массив в который будут скопированы данные
source – массив источник копируемых данных
c – код символа, при встрече которого копирование завершается
n – количество байт для копирования

void *memmove( void *destination, const void *source, size_t n )
destination – массив в который будут скопированы данные.
source – массив источник копируемых данных.
n – количество байт для копирования
*При этом массивы (области памяти) могут пересекаться

void *memchr( const void *arr, int c, size_t n )
arr – массив, в котором будет осуществляться поиск
с – код искомого символа
n – размер сравниваемой части массива в байтах

int memcmp( const void *arr1, const void *arr2, size_t n )
arr1, arr2 – сравниваемые массивы
n – размер сравниваемой части массива в байтах

void *memset( void *destination, int c, size_t n )
Заполняет первые n байт области памяти destination, символом, код которого указывается аргументом c
destination – заполняемый массив
с – код символа для заполнения
n – размер заполняемой части массива в байтах